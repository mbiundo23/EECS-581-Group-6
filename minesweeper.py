'''
File: minesweeper.py
Description: Implementation of a terminal based Minesweeper game made with Python.
Inputs: User gives input for uncovering or flagging cells and can change difficulty level by selecting bomb amount.
Outputs: Game board and progression is showed on display.
External sources: None
Authors: Bisshoy Bhattacharjee, Josh Welicky, Max Biundo, Marcus Kitchin, Gavin Billinger
Last updated: 9/19/2025
'''
import random
import os
import time

GRID_SIZE =  10

'''
Helper function to clear the terminal so output doesn't get too cluttered.
The clear command is different on windows vs linx/mac, so different 
os.system calls are needed.

This basic function structure was generated by the google search AI.
'''
def clear():
        # case for Windows OS
        if os.name == 'nt':
                os.system('cls')
        # case for Linux/MAC
        else:
                os.system('clear')
'''
A data structure that represents a single cell in a game grid. 
It contains all relevant information about the state of the cell, such as the number of adjacent mines, whether or not it has been uncovered, 
whether or not it contains a bomb, and whether or not it is currently flagged.
'''
class Cell:
        #Represents a single cell on the minesweeper board
        def __init__(self): # Initialize a cell with default values
                self.adjMines = 0 # Number of adjacent mines
                self.covered = True # If the cell is still covered
                self.bomb = False # If the cell contains a bomb
                self.flagged = False # If the cell is flagged by the player

        def __str__(self):
                #for debugging - shows bomb if uncovered
                if self.bomb and not self.covered:
                        return "üí£"
                if self.flagged:
                        return "üö©" # Shows flag if flagged
                elif self.covered:
                        return '  ' # Empty string for covered cell
                else:
                        return f" {str(self.adjMines)}" # Show number of adjacent mines if uncovered
'''
Represents the actual grid in a game of Minesweeper. This class can be considered as a list with additional methods. 
In this program, the grid is represented as a single-dimensional list, where neighboring cells are derived mathematically through the getNeighbors method.
'''
class Board: # Represents the minesweeper board and handles neighbor calcualtions and display"
        # Initialize the board with 101 cell instances (inded 1-101) -(Changed to 1 to chosen grid size)

        def __init__(self): 
                self._board: list[Cell] = []
                for i in range(1, (GRID_SIZE * GRID_SIZE) + 2):
                        self._board.append(Cell()) # Create a new cell for each board position

        # OVERLOAD INDEXING
        def __getitem__(self, i):  
                if isinstance(i, int):
                        return self._board[i] # Return the cell at index i
                else:
                        raise # Raises error if index is not an integer
        
        # Returns the total number of cells on the board
        def __len__(self): 
                return len(self._board)
        

        # FUNCTION TO DISPLAY USER'S BOARD
        def display(self): 
                if GRID_SIZE == 10:
                        print('     A   B   C   D   E   F   G   H   I   J  ') # Prints column header

                elif GRID_SIZE == 15:
                        print('     A   B   C   D   E   F   G   H   I   J   K   L   M   N   O  ') 

                elif GRID_SIZE == 25:
                        print('     A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y  ') 
                test_string = ''
                for i in range(GRID_SIZE): # Loop over rows
                        for j in range(GRID_SIZE): # Loop over columns
                                index = (i * GRID_SIZE) + j + 1
                                test_string += '[' + str(self._board[index]) + ']'

                        row_num = str(i + 1)
                        padding = ' ' * (4 - len(row_num))
                        print(padding + row_num + test_string)
                        test_string = '' # Empty test string.
                return

        # Helps narrow the spaces to check bombs for a given space
        @staticmethod
        def getNeighbors(num): 
                # First, we'll classify the num as LeftEdge or RightEdge
                isLeftEdge = False
                isRightEdge = False
                if ((num-1)% GRID_SIZE) == 0: # This singles out 1, 11, 21, 31, etc as left edges.
                        isLeftEdge = True
                if (num% GRID_SIZE) == 0: # This singles out 10, 20, 30, 40, as right edges.
                        isRightEdge = True
                neighbors = []
                if not isRightEdge:
                        neighbors.append(num + 1) # Add right
                if not isLeftEdge:
                        neighbors.append(num - 1) # Add left
                if (num + GRID_SIZE < (GRID_SIZE * GRID_SIZE) + 1):
                        neighbors.append(num + GRID_SIZE) # Add down
                if (num - GRID_SIZE > 0):
                        neighbors.append(num - GRID_SIZE) # Add up
                if (not isLeftEdge) and (num - GRID_SIZE > 0):
                        neighbors.append(num - GRID_SIZE + 1) # Add up-left
                if (not isRightEdge) and (num - GRID_SIZE > 0):
                        neighbors.append(num - GRID_SIZE - 1) # Add up-right
                if (not isLeftEdge) and (num + GRID_SIZE < (GRID_SIZE * GRID_SIZE) + 1):
                        neighbors.append(num + GRID_SIZE - 1) # Add down-left
                if (not isRightEdge) and (num + GRID_SIZE < (GRID_SIZE * GRID_SIZE) + 1):
                        neighbors.append(num + GRID_SIZE + 1) # Add down-right
                return neighbors
        
        @staticmethod
        def getCellString(index: int) -> str:
                letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                letterIndex = ((index - 1) % GRID_SIZE)
                return letters[letterIndex] + str(((index // GRID_SIZE) + 1 - ( 1 if letterIndex == GRID_SIZE - 1 else 0)))

class AI:
        def __init__(self, difficulty: str):
                self.difficulty = difficulty

        def get_move(self, board: Board) -> int:
                if self.difficulty == "E":
                        return AI.easy(board)
                elif self.difficulty == "M":
                        return AI.medium(board)
                else:
                        return AI.hard(board)

        @staticmethod
        def easy(board: Board) -> int:
                return -1

        @staticmethod
        def medium(board: Board) -> int:
                # row,col =random.randint(1, 11),random.randint(1, 11)
                # space = ((row - 1) * 10) + col
                # First, if the number of hidden neighbors of a revealed cell equals that cell‚Äôs number, the AI should flag all hidden neighbors.
                rule_1_flag = 0
                rule_2_flag = 0
                bomb_count=0
                flag_count=0

                for i in range(len(board)):
                        if board[i].flagged==True:
                                flag_count+=1
                        if board[i].bomb==True:
                                bomb_count+=1

                for i in range(len(board)):  # check every cell
                        hidden_neighbors = 0
                        flagged_neighbors = 0
                        if board[i].covered == False:  # revealed is true
                                possible_neighbors = board.getNeighbors(i)
                                for neighbor in possible_neighbors:
                                        if board[neighbor].covered: #add to hidden neighbors if is covered
                                                hidden_neighbors += 1
                                if hidden_neighbors == board[i].adjMines:  # First, if the number of hidden neighbors of a revealed cell equals that cell‚Äôs number, the AI should flag all hidden neighbors.
                                        for neighbor in possible_neighbors:
                                                if (flag_count + 1 <= bomb_count) and board[neighbor].covered == True:
                                                        board[neighbor].flagged = True
                                                        flag_count += 1

                                for neighbor in possible_neighbors: # get the amount of flag neighbors for rule 2
                                        if board[neighbor].flagged == True:
                                                flagged_neighbors += 1

                                if flagged_neighbors == board[i].adjMines:  # Second, if the number of flagged neighbors of a revealed cell equals that cell‚Äôs number, the AI should open all other hidden neighbors.
                                        for neighbor in possible_neighbors:
                                                if board[neighbor].flagged == False:
                                                              return i


                return AI.easy(board)

        @staticmethod
        def hard(board: Board) -> int:
                AI.neighborsList = [Board.getNeighbors(i) for i in range(len(board))]
                AI.timeout = time.time() + 3
                safeCell = AI.getSafeCell(board)
                return safeCell if safeCell > 0 else AI.medium(board)

        neighborsList = []
        timeout = 0

        @staticmethod
        def getSafeCell(board: Board) -> int:
                allowedNeighbors = [(-1 if cell.covered else cell.adjMines) for cell in board]
                ignoreCells = [True for _ in board]

                globalPlacedMines = [False for _ in allowedNeighbors]
                placedMine = True

                while placedMine:
                        placedMine = False

                        for i in range(1, len(allowedNeighbors)):
                                if allowedNeighbors[i] < 0:
                                        continue

                                ignoreCells[i] = False

                                neighbors = AI.neighborsList[i]

                                for neighbor in neighbors:
                                        if ignoreCells[neighbor] and allowedNeighbors[neighbor] <= -1 and not globalPlacedMines[neighbor]:
                                                ignoreCells[neighbor] = False

                                if allowedNeighbors[i] == 0:
                                        ignoreCells[i] = True
                                        continue
                                
                                freeNeighbors = [cell for cell in neighbors if (allowedNeighbors[cell] <= -1 and not globalPlacedMines[cell])]
                                if allowedNeighbors[i] == len(freeNeighbors):
                                        for cell in freeNeighbors:
                                                ignoreCells[cell] = True
                                                globalPlacedMines[cell] = True
                                                for index in AI.neighborsList[cell]:
                                                        if allowedNeighbors[index] < 0:
                                                                continue

                                                        allowedNeighbors[index] = board[index].adjMines
                                                        for nn in AI.neighborsList[index]:
                                                                if globalPlacedMines[nn]:
                                                                        allowedNeighbors[index] -= 1

                                                #print(f"{Board.getCellString(cell)} is a mine.")
                                        placedMine = True

                for i in range(1, len(allowedNeighbors)):
                        if ignoreCells[i]:
                                continue

                        if allowedNeighbors[i] >= 0:
                                continue

                        if globalPlacedMines[i]:
                                continue

                        neighbors = AI.neighborsList[i]

                        for neighbor in neighbors:
                                if allowedNeighbors[neighbor] == 0:
                                        return i
                                
                for i in range(1, len(allowedNeighbors)):
                        if allowedNeighbors[i] != 2:
                                continue

                        up = i - GRID_SIZE
                        down = i + GRID_SIZE
                        left = i - 1
                        right = i + 1

                        upGood = up > 0
                        downGood = down < len(allowedNeighbors)
                        leftGood = i % GRID_SIZE != 0
                        rightGood = i % GRID_SIZE != GRID_SIZE - 1

                        if upGood and downGood and allowedNeighbors[up] == 1 and allowedNeighbors[down] == 1:
                                if leftGood:
                                        if allowedNeighbors[left] < 0 and allowedNeighbors[down - 1] < 0 and allowedNeighbors[up - 1] < 0:
                                                return left
                                
                                if rightGood:
                                        if allowedNeighbors[right] < 0 and allowedNeighbors[down + 1] < 0 and allowedNeighbors[up + 1] < 0:
                                                return right
                                        
                        if leftGood and rightGood and allowedNeighbors[left] == 1 and allowedNeighbors[right] == 1:
                                if upGood:
                                        if allowedNeighbors[up] < 0 and allowedNeighbors[up - 1] < 0 and allowedNeighbors[up + 1] < 0:
                                                return up
                                        
                                if downGood:
                                        if allowedNeighbors[down] < 0 and allowedNeighbors[down - 1] < 0 and allowedNeighbors[down + 1] < 0:
                                                return down
                

                for i in range(1, len(allowedNeighbors)):
                        if time.time() > AI.timeout:
                                return -1

                        if ignoreCells[i]:
                                continue

                        if allowedNeighbors[i] >= 0:
                                continue

                        if globalPlacedMines[i]:
                                continue

                        neighbors = AI.neighborsList[i]

                        loop: list[int] = []
                        AI.getLoop(ignoreCells, i, loop)

                        solution = AI.solveLoop(ignoreCells, allowedNeighbors, loop, globalPlacedMines)

                        if solution != -1:
                                return solution
                        
                        for cell in loop:
                                ignoreCells[cell] = True

                return -1
        
        @staticmethod
        def canPutMine(allowedNeighbors: list[int], cell: int) -> bool:
                if allowedNeighbors[cell] >= 0:
                        return False

                neighbors = AI.neighborsList[cell]

                for index in neighbors:
                        if allowedNeighbors[index] == 0:
                                return False
                
                return True

        @staticmethod
        def putMine(ignore: list[bool], allowedNeighbors: list[int], cell: int) -> bool:
                if allowedNeighbors[cell] >= 0:
                        return False

                neighbors = AI.neighborsList[cell]

                for index in neighbors:
                        if allowedNeighbors[index] == 0:
                                return False
                
                for index in neighbors:
                        allowedNeighbors[index] -= 1
                
                ignore[cell] = True
                
                return True

        @staticmethod 
        def removeMine(ignore: list[bool], allowedNeighbors: list[int], cell: int):
                ignore[cell] = False

                for index in AI.neighborsList[cell]:
                        allowedNeighbors[index] += 1

        @staticmethod
        def getLoop(ignore: list[bool], cell: int, loop: list[int]):
                if ignore[cell]:
                        return
                
                if cell in loop:
                        return
                
                loop.append(cell)

                for index in AI.neighborsList[cell]:
                        if ignore[index]:
                                continue
                        AI.getLoop(ignore, index, loop)
        
        @staticmethod
        def solveLoop(ignore: list[bool], allowedNeighbors: list[int], loop: list[int], globalPlacedMines: list[bool]) -> int:

                #loop = [item for item in loop if allowedNeighbors[item] < 0]

                for i in loop:
                        if time.time() > AI.timeout:
                                return -1

                        if globalPlacedMines[i]:
                                continue

                        if allowedNeighbors[i] >= 0:
                                continue

                        if not AI.putMine(ignore, allowedNeighbors, i):
                                return i
                        
                        banned = [not AI.canPutMine(allowedNeighbors, i) for i in range(len(allowedNeighbors))]
                        
                        thisPlacedMines = [False for _ in ignore]
                        thisPlacedMines[i] = True

                        if AI.tryFindSolution(ignore, allowedNeighbors, loop, thisPlacedMines, globalPlacedMines, banned, 1):
                                AI.removeMine(ignore, allowedNeighbors, i)
                                continue
                        
                        AI.removeMine(ignore, allowedNeighbors, i)
                        return i
                
                return -1


        @staticmethod
        def tryFindSolution(ignore: list[bool], allowedNeighbors: list[int], loop: list[int], thisPlacedMines: list[bool], globalPlacedMines: list[bool], banned: list[bool], start: int) -> bool:
                solved = True
                
                for item in loop:
                        if allowedNeighbors[item] > 0:
                                solved = False
                                break
                
                if solved:
                        for i, canBeMine in enumerate(thisPlacedMines):
                                if canBeMine:
                                        globalPlacedMines[i] = True
                                        #print(f"{Board.getCellString(i)} is bad.")
                        return True

                for i, cell in enumerate(loop):
                        if time.time() > AI.timeout:
                                return True

                        if thisPlacedMines[cell]:
                                continue

                        if banned[cell]:
                                continue

                        if not AI.putMine(ignore, allowedNeighbors, cell):
                                continue

                        thisPlacedMines[cell] = True

                        for neighbor in AI.neighborsList[cell]:
                                if not AI.canPutMine(allowedNeighbors, neighbor):
                                        banned[neighbor] = True

                        if AI.tryFindSolution(ignore, allowedNeighbors, loop, thisPlacedMines, globalPlacedMines, banned, i + 1):
                                AI.removeMine(ignore, allowedNeighbors, cell)
                                return True
                        
                        AI.removeMine(ignore, allowedNeighbors, cell)
                        thisPlacedMines[cell] = False

                        for neighbor in AI.neighborsList[cell]:
                                if AI.canPutMine(allowedNeighbors, neighbor):
                                        banned[neighbor] = False
                
                solved = True

                for item in loop:
                        if allowedNeighbors[item] > 0:
                                solved = False
                                break
                
                if solved:
                        for i, canBeMine in enumerate(thisPlacedMines):
                                if canBeMine:
                                        globalPlacedMines[i] = True
                                        #print(f"{Board.getCellString(i)} is bad.")
                        return True
                
                return False




'''
An entity that represents a single game of Minesweeper and all of its relevant information, including game status, bomb counts, flagged cell counts, start time, and the game grid. 
It also contains the functionality for obtaining user commands and handling all game logic.
'''        
class Game:
        # Handles game logic like moves, win/loss checking, and propagation
        def __init__(self): # Initialize the game state and create a board
                self.status = 'Playing' # Current game state
                self.flag_ct = 0 # Number of flags currently placed
                self.bomb_ct = 0 # Total bombs in the game
                self.bomb_spaces = [] # List of bomb positions
                self.start_time = time.time() #initialize the start time of the game
                #self.board = Board() # initialize the game board
                self.score = 0 # initialize score
                self.total_moves = 0 # initialize total moves
                self.wrong_flags = 0 # initialize wrong flags

        
        def caclulateScore(self):
                # Count only real board indices (1..N); index 0 is unused in this implementation
                safe_cells = sum(1 for i in range(1, len(self.board)) if not self.board[i].bomb)
                # Safe cells that have been uncovered
                revealed_safe = sum(1 for i in range(1, len(self.board)) if (not self.board[i].bomb) and (not self.board[i].covered))
                # Flags that correctly mark bombs are considered "revealed" for scoring
                correct_flags = sum(1 for i in range(1, len(self.board)) if self.board[i].bomb and self.board[i].flagged)

                # Avoid division by zero so if no safe cells, consider board fully cleared
                if safe_cells == 0:
                        percent_cleared = 1.0
                else:
                        percent_cleared = (revealed_safe + correct_flags) / safe_cells
                        # Clamp to [0,1] just in case
                        percent_cleared = max(0.0, min(1.0, percent_cleared))

                base_score = (self.bomb_ct * 10) - (self.wrong_flags * 5)
                computed = base_score * percent_cleared
                if computed < 0:
                        computed = 0
                # Round for display / storage
                self.score = round(computed, 2)
                return self.score

        # Helper function to check the elapsed time of the game
        def timeCheck(self):
                cur_time = time.time() #check the time
                elapsed_time = cur_time - self.start_time #subtract the start time from recent check
                return elapsed_time #return the current time unformatted
        

        #function to display the current time to the user
        def displayTime(self): 
                elapsed_time = self.timeCheck() #do a time check
                hours = int(elapsed_time // 3600 % 24) #mathematical functions to formate raw number
                minutes = int(elapsed_time // 60 % 60)
                seconds = int(elapsed_time % 60)
                formatted_time = f"{hours:02d}:{minutes:02d}:{seconds:02d}" #format into hh:mm:ss
                print("Time:", formatted_time) #print


        # Display the current board, game status, and number of remaining mines
        def printGame(self): 
                self.displayTime()
                self.board.display() # Print the board
                print("Current status:", self.status) # Shows game status
                print("Mines remaining:", self.bomb_ct - self.flag_ct, "\n") # Shows remaining mines
                if self.status != "Playing":
                        print("Final Score:", round(self.caclulateScore(), 2)) # Show final score if game is over
                return


        # Places bombs within the Cell instances stored in board. Requires bomb_spaces to be derived first.
        def placeBombs(self): 
                for i in range(len(self.bomb_spaces)):
                        bomb_idx = self.bomb_spaces[i] # Get location of bomb
                        self.board[bomb_idx].bomb = True # Insert bomb character

                # Now we just need to fill values around bombs!

                for i in range(1, len(self.board)): # For every space in the board we need to find how many bombs are around it.
                        if (self.board[i].bomb):
                                continue # We don't need the value where bombs are so we skip.
                        space_val = 0
                        neighbors = Board.getNeighbors(i) # We'll get the valid indices in separate function.
                        for index in neighbors: # Iterate through neighbor list
                                if (self.board[index].bomb): # If the board at that neighbor is a bomb...
                                        space_val += 1 # ...increment space value
                        self.board[i].adjMines = space_val # Set value at that board space.


        # Recursively uncovers neighbouring cells starting from a cell with 0 nearby mines.
        def propagate(self, space): 
                self.board[space].covered = False
                neighbors = Board.getNeighbors(space)
                for neighbor in neighbors: # if neighbour has 0 adjacent mines and is not flagged, it will recusively uncover
                        if self.board[neighbor].adjMines == 0 and self.board[neighbor].flagged == False:
                                if self.board[neighbor].covered:
                                        self.propagate(neighbor)
                        elif self.board[neighbor].flagged: # Skip flagged cells
                                continue
                        else:
                                #print(f"Cell {neighbor}")
                                self.board[neighbor].covered = False


        # Display an error message and wait for the user to press "ENTER". Needed to preserve help messages before clearing terminal.
        def printErr(self, msg): 
                print(msg)
                input("Press [ENTER] to continue...\n")


        # Obtains an input from the user and parses it into a game command, broken into [action, row, column].
        def getInput(self):
                i = True
                while i:
                        try:
                                inp_string = input('Mine a cell with m[row][col].\nToggle a flag with f[row][col].\nPlease give command: ') # Ask for command.
                                com_type = inp_string[0].lower() # Parse first character for command type ("m" or "f")
                                if com_type != 'm' and com_type != 'f':
                                        raise
                                inp_string = inp_string[1:len(inp_string)] # Remove first character from input string.
                
                                col = inp_string[len(inp_string)-1] # Look at end of input string for column letter.
                                cols = [chr(97 + i) for i in range(GRID_SIZE)]
                                if col not in cols:
                                        raise
                                col = cols.index(col) + 1 # Translate that column into numerical column position.
                                inp_string = inp_string[:len(inp_string)-1] # Remove last character from input string.
                
                                row = int(inp_string) # What's remaining of input string should be row number.
                                if row not in range(1, GRID_SIZE + 1):
                                        raise
                                i = False
                        except:
                                err_msg = '\nCommand is faulty please follow command, row, column format.\n(Hint 1: To mine at row 1, column a, type "m1a")\n(Hint 2: To flag at row 7, column g, type "f7g")'
                                self.printErr(err_msg)
                                continue
                
                command = [] # Create command value.
                command.append(com_type) # Add the "m" or "f"
                command.append(row) # Add row number.
                command.append(col) # Add column number.
                return command # Return parsed input.



        #Collects the bomb amount from the user and generates an initial list of bomb space indices.
        #Feature added: indludes a grid size option
        def configure(self):
                global GRID_SIZE
                # Collect grid size preference using same structure
                i = 0
                while i == 0:
                        try:
                                size_input = input("Chose Grid Size - Small 10 x 10, Medium 15 x 15, Large 25 x 25 (Please enter s, m or l): ").lower()

                                if size_input == 's':
                                        GRID_SIZE = 10 
                                elif size_input == 'm':
                                        GRID_SIZE = 15
                                elif size_input == 'l':
                                        GRID_SIZE = 25
                                i = 1
                        except: 
                                print("Invalid Grid Size")
                self.board = Board() #update board size 
                                
                # COLLECT BOMB AMOUNT (DIFFICTULTY)
                # The added feature includes adding a different range for each grid size 

                #calculate minnimum an maximum for bomb sizes
                bomb_min =  (GRID_SIZE * GRID_SIZE)// 10
                bomb_max = (GRID_SIZE * GRID_SIZE) // 5
                i = 0 
                while i == 0: # This while loop is purely for error handling. We don't stop asking until we get workable input!
                        try:
                                self.bomb_ct = int(input('How many bombs should there be?: '))
                                if self.bomb_ct < bomb_min or self.bomb_ct > bomb_max: # Bomb count must be between 10 and 20 per the requirements. (Changed to 10-20% of grid size)
                                        raise
                                i = 1
                        except:
                                print("Invalid bomb count. Please input again.")

                self.bomb_spaces = random.sample(range(1,((GRID_SIZE * GRID_SIZE) + 1)), self.bomb_ct) # Randomly select bomb locations on the board without duplicates



        '''
        Main game logic function. First, it obtains a valid command from the user and derives the space from the last two components. 
        Handles the operations necessary to flag a Cell(directly alters a Cell's flagged attribute) and handles all rule checks. 
        If the command is to mine, the Cell is uncovered. If the Cell has no adjacent mines, propagate() is called, which uncovers the Cell automatically. 
        If not, the Cell is uncovered directly in move(). Behavior is slightly different based on the prebomb attribute. 
        If it is set to True, the selected space is checked for presence in the randomly generated bomb_spaces list. 
        If it is present, then a new bomb_space is generated. 
        Once the bomb_spaces list is adjusted, placeBombs() is called, installing bombs in the board attribute. 
        Then, the Cell is uncovered as normal. If a bomb space is selected and prebomb is False, all bomb spaces are uncovered, and the game status is set to ‚ÄúGame Over: Loss‚Äù.
        '''
        def move(self, prebomb=False):
                self.total_moves += 1 # Increment total moves
                user_input = self.getInput() # Helper function gives us actionable command.
                space = ((user_input[1]-1) * GRID_SIZE) + user_input[2] # Translate col and row from input into board space.
                
                if user_input[0] == 'f': # If we got a flag command, we place the flag on display.
                        if not self.board[space].flagged: # Empty space means flag is allowed.
                                        if self.checkBombPlacement() and self.flag_ct + 1 > self.bomb_ct: # Also got to check that we don't place too many flags.
                                                self.printErr("Cannot flag any more spaces. Please unflag with flag command.")
                                        elif not self.board[space].covered:
                                                self.printErr("Cannot flag an uncovered space.")
                                        else:
                                                self.board[space].flagged = True # Put a flag on the display!
                                                self.flag_ct += 1 # Increment the amount of flags on board.
                                                if not self.board[space].bomb:
                                                        self.wrong_flags += 1 # Increment wrong flags if flag is placed on non-bomb space
                        elif self.board[space].flagged: # Flag exists in current space, remove it.
                                self.board[space].flagged = False # Set flag to empty space.
                                self.flag_ct -= 1 # Decrement the amount of flags on board.
                
                elif user_input[0] == 'm': # We have a mine command!
                        if self.board[space].flagged: # Are we mining on a flag space?
                                self.printErr('Cannot mine a flag given space.') # We don't actually do anything. We just say a flag is in the way.
                        else:
                                if prebomb:
                                        # SPACE-BOMB COLLISION PROBLEM
                                        if space in self.bomb_spaces: # In the event the selected space is where a mine was planned to be...
                                                problem_index = self.bomb_spaces.index(space) # Isolate where in the list of bomb spaces the user space and bomb collide.
                                                while space == self.bomb_spaces[problem_index]: # While these two values are the same...
                                                        self.bomb_spaces[problem_index] = random.randint(1, GRID_SIZE * GRID_SIZE) # ...we will reroll that bomb space.
                                                        i = 0 # Then we'll check how many times the new bomb space value appears.
                                                        for place in self.bomb_spaces: # Check every bomb space
                                                                if self.bomb_spaces[problem_index] == place: # If the new space appears in bomb spaces, increment.
                                                                        i += 1 # This should increment only once (when the new space compares itself).
                                                        if i > 1: # If the new bomb space increments multiple times, we still have a collision.
                                                                self.bomb_spaces[problem_index] = space # We can't let the while loop end so reset with space.
                                        
                                        # CALL BOARD GENERATION
                                        self.placeBombs()
                                        # UPDATE BOARD w/ FIRST SPACE
                                        if self.board[space].adjMines == 0:
                                                self.propagate(space) # Reveal spaces around the 0 space.
                                        else:
                                                self.board[space].covered = False
                                else:
                                        # There's a few things we check here:
                                                # Is the space a bomb?
                                                # Is the space a flag?
                                                # Is the space 0?
                                                # Is the space any other value?
                                        # We will check if the space is a bomb next.
                                        if self.board[space].bomb:
                                                for bomb in self.bomb_spaces: # Reveal all bombs on the board.
                                                        self.board[bomb].covered = False
                                                self.status = "Game Over: Loss" # Lose the game.
                                        # We will check if the space is the value 0.
                                        elif self.board[space].adjMines == 0: # 0 is a special value because we...
                                                self.propagate(space) # ...reveal the neighbor values.
                                        # The space must be empty and a regular number. Reveal it!
                                        else:
                                                self.board[space].covered = False


        #Checks if all non-bomb spaces are uncovered. Doesn't return anything, but sets status to Victory if necessary.
        def checkWin(self):
                # CHECK WIN CONDITION
                remaining_space_check = 0
                for index in range(1, len(self.board)): # Compare all board spaces
                        if self.board[index].covered:
                                remaining_space_check += 1 # Increment remaining empty or flagged spaces.
                if remaining_space_check == self.bomb_ct: # When there are the same amount of empty or flagged spaces as bombs on the field...
                        self.status = "Victory!" # The game has been won! End game loop.
                    

        # Check if all bombs have been correctly placed on the board. Needed to ensure first mined cell doesn't actually have a bomb in it.
        def checkBombPlacement(self): 
                bombed_spaces = 0
                for index in range(1, len(self.board)):
                        if self.board[index].bomb:
                                bombed_spaces += 1 # Count the number of bombs currently on the board
                return bombed_spaces == self.bomb_ct # Return true if bomb count matches the intended total


        '''
        Comprises the main game loop. Initially configures the game with configure(). 
        Then, runs a while loop, which prints the state of the game (printGame()) and requests a command (move()). 
        The optional parameter for move is set to True in this loop(see move() description). 
        This loop ends once the bombs have been placed (once the user uncovers their first cell). 
        After that, another loop begins, performing essentially the same function, with two differences. 
        The optional command in move() is no longer set, and the checkWin() function is called at the end of every iteration. 
        The loop breaks once the game status is no longer ‚ÄúPlaying‚Äù.
        '''
        def play(self): # Configures the board, processes moves, and handle win/loss
                self.configure() # Ask user for bomb count and generate bomb locations
                while not self.checkBombPlacement(): # Makes sure bombs are properly placed before starting the game
                        self.printGame()
                        #print(f"Bomb Spaces: {self.bomb_spaces}")
                        self.move(True)
                        clear()
                while self.status == 'Playing':
                        self.printGame() # Display the current board
                        #print(f"Bomb Spaces: {self.bomb_spaces}")
                        self.move()
                        self.checkWin()
                        clear() # Clear screen for a fresh board display
                self.printGame()
                return



'''
Entity that coordinates initial contact with the user. It is responsible for printing an initial introductory message, as well as enabling multiple games per execution.
'''
class GameManager: # Handles showing instructions, new games, and replayability
        #GameManager doesn't need any attributes.
        def __init__(self):
                return
        
        # Creates a new game instance and start playing it
        def newGame(self): 
                newgame = Game()
                newgame.play()
        
        # Display the initial instruction to the player.
        def start_message(self): 
                print('Welcome to Minesweeper!')
                print('--------------------------------')
                print('HOW TO PLAY:')
                print('- Goal: uncover all safe spaces without hitting a mine.')
                print('- The numbers show how many mines are in the surrounding spaces.')
                print('- Commands (one command per turn):')
                print('    m[row][col] ‚Üí Uncover a space.')
                print('        Example: m3b means uncover row 3, column b.')
                print('    f[row][col] ‚Üí Flag or unflag a space.')
                print('        Example: f5h means place/remove a flag at row 5, column h.')
                print('- Win by uncovering every safe space. If you hit a mine, you lose!.')
                print('--------------------------------')
       
        # Start the game manager to show introduction instrution, run game and handle replays.
        def start(self):
                self.start_message() # Displays instruction to player
                while True:
                        self.newGame() # Start a new game
                        choice = input("Play again?(yes/no): ") # Ask if player want to reply
                        if choice.lower() == 'yes' or choice.lower() == 'y':
                                clear() # Clear screen for a fresh game
                                continue # Starts new game
                        else:
                                break # Exit loop and end the program

# Create a GameManager instance and start the minesweeper game
def main(): 
        manager = GameManager()
        manager.start()

main()
