'''
File: minesweeper.py
Description: Implementation of a terminal based Minesweeper game made with Python.
Inputs: User gives input for uncovering or flagging cells and can change difficulty level by selecting bomb amount.
Outputs: Game board and progression is showed on display.
External sources: None
Authors: Bisshoy Bhattacharjee, Josh Welicky, Max Biundo, Marcus Kitchin, Gavin Billinger
Last updated: 9/19/2025
'''
import random
import os
import time

'''
Helper function to clear the terminal so output doesn't get too cluttered.
The clear command is different on windows vs linx/mac, so different 
os.system calls are needed.

This basic function structure was generated by the google search AI.
'''
def clear():
        # case for Windows OS
        if os.name == 'nt':
                os.system('cls')
        # case for Linux/MAC
        else:
                os.system('clear')






'''
A data structure that represents a single cell in a game grid. 
It contains all relevant information about the state of the cell, such as the number of adjacent mines, whether or not it has been uncovered, 
whether or not it contains a bomb, and whether or not it is currently flagged.
'''
class Cell:
        #Represents a single cell on the minesweeper board
        def __init__(self): # Initialize a cell with default values
                self.adjMines = 0 # Number of adjacent mines
                self.covered = True # If the cell is still covered
                self.bomb = False # If the cell contains a bomb
                self.flagged = False # If the cell is flagged by the player

        def __str__(self):
                #for debugging - shows bomb if uncovered
                if self.bomb and not self.covered:
                        return "💣"
                if self.flagged:
                        return "🚩" # Shows flag if flagged
                elif self.covered:
                        return '  ' # Empty string for covered cell
                else:
                        return f" {str(self.adjMines)}" # Show number of adjacent mines if uncovered







'''
Represents the actual grid in a game of Minesweeper. This class can be considered as a list with additional methods. 
In this program, the grid is represented as a single-dimensional list, where neighboring cells are derived mathematically through the getNeighbors method.
'''
class Board: # Represents the minesweeper board and handles neighbor calcualtions and display"
        # Initialize the board with 101 cell instances (inded 1-101)
        def __init__(self): 
                self._board = []
                for i in range(1, 102):
                        self._board.append(Cell()) # Create a new cell for each board position

        # OVERLOAD INDEXING
        def __getitem__(self, i):  
                if isinstance(i, int):
                        return self._board[i] # Return the cell at index i
                else:
                        raise # Raises error if index is not an integer
        
        # Returns the total number of cells on the board
        def __len__(self): 
                return len(self._board)
        

        # FUNCTION TO DISPLAY USER'S BOARD
        def display(self): 
                print('     A   B   C   D   E   F   G   H   I   J  ') # Prints column header
                test_string = ''
                for i in range(10): # Loop over rows
                        for j in range(10): # Loop over columns
                                test_string += '[' + str(self._board[(((i*10)+j)+1)]) +']'
                        if (i+1 != 10): # Prints rows with built string above.
                                print(str(i+1) + '  ' + test_string)
                        else: # Row 10 requires less space between itself and test string.
                                print(str(i+1) + ' ' + test_string)
                        test_string = '' # Empty test string.
                return

        # Helps narrow the spaces to check bombs for a given space
        def getNeighbors(self, num): 
                # First, we'll classify the num as LeftEdge or RightEdge
                isLeftEdge = False
                isRightEdge = False
                if ((num-1)%10) == 0: # This singles out 1, 11, 21, 31, etc as left edges.
                        isLeftEdge = True
                if (num%10) == 0: # This singles out 10, 20, 30, 40, as right edges.
                        isRightEdge = True
                neighbors = []
                if not isRightEdge:
                        neighbors.append(num + 1) # Add right
                if not isLeftEdge:
                        neighbors.append(num - 1) # Add left
                if (num + 10 < 101):
                        neighbors.append(num + 10) # Add down
                if (num - 10 > 0):
                        neighbors.append(num - 10) # Add up
                if (not isLeftEdge) and (num-10 > 0):
                        neighbors.append(num - 11) # Add up-left
                if (not isRightEdge) and (num-10 > 0):
                        neighbors.append(num - 9) # Add up-right
                if (not isLeftEdge) and (num+10 < 101):
                        neighbors.append(num + 9) # Add down-left
                if (not isRightEdge) and (num+10 < 101):
                        neighbors.append(num + 11) # Add down-right
                return neighbors




'''
An entity that represents a single game of Minesweeper and all of its relevant information, including game status, bomb counts, flagged cell counts, start time, and the game grid. 
It also contains the functionality for obtaining user commands and handling all game logic.
'''        
class Game:
        # Handles game logic like moves, win/loss checking, and propagation
        def __init__(self): # Initialize the game state and create a board
                self.status = 'Playing' # Current game state
                self.flag_ct = 0 # Number of flags currently placed
                self.bomb_ct = 0 # Total bombs in the game
                self.bomb_spaces = [] # List of bomb positions
                self.start_time = time.time() #initialize the start time of the game
                self.board = Board() # initialize the game board
                self.score = 0 # initialize score
                self.total_moves = 0 # initialize total moves
                self.wrong_flags = 0 # initialize wrong flags

        
        def caclulateScore(self):
                # Count only real board indices (1..N); index 0 is unused in this implementation
                safe_cells = sum(1 for i in range(1, len(self.board)) if not self.board[i].bomb)
                # Safe cells that have been uncovered
                revealed_safe = sum(1 for i in range(1, len(self.board)) if (not self.board[i].bomb) and (not self.board[i].covered))
                # Flags that correctly mark bombs are considered "revealed" for scoring
                correct_flags = sum(1 for i in range(1, len(self.board)) if self.board[i].bomb and self.board[i].flagged)

                # Avoid division by zero so if no safe cells, consider board fully cleared
                if safe_cells == 0:
                        percent_cleared = 1.0
                else:
                        percent_cleared = (revealed_safe + correct_flags) / safe_cells
                        # Clamp to [0,1] just in case
                        percent_cleared = max(0.0, min(1.0, percent_cleared))

                base_score = (self.bomb_ct * 10) - (self.wrong_flags * 5)
                computed = base_score * percent_cleared
                if computed < 0:
                        computed = 0
                # Round for display / storage
                self.score = round(computed, 2)
                return self.score

        # Helper function to check the elapsed time of the game
        def timeCheck(self):
                cur_time = time.time() #check the time
                elapsed_time = cur_time - self.start_time #subtract the start time from recent check
                return elapsed_time #return the current time unformatted
        

        #function to display the current time to the user
        def displayTime(self): 
                elapsed_time = self.timeCheck() #do a time check
                hours = int(elapsed_time // 3600 % 24) #mathematical functions to formate raw number
                minutes = int(elapsed_time // 60 % 60)
                seconds = int(elapsed_time % 60)
                formatted_time = f"{hours:02d}:{minutes:02d}:{seconds:02d}" #format into hh:mm:ss
                print("Time:", formatted_time) #print


        # Display the current board, game status, and number of remaining mines
        def printGame(self): 
                self.displayTime()
                self.board.display() # Print the board
                print("Current status:", self.status) # Shows game status
                print("Mines remaining:", self.bomb_ct - self.flag_ct, "\n") # Shows remaining mines
                if self.status != "Playing":
                        print("Final Score:", round(self.caclulateScore(), 2)) # Show final score if game is over
                return


        # Places bombs within the Cell instances stored in board. Requires bomb_spaces to be derived first.
        def placeBombs(self): 
                for i in range(len(self.bomb_spaces)):
                        bomb_idx = self.bomb_spaces[i] # Get location of bomb
                        self.board[bomb_idx].bomb = True # Insert bomb character

                # Now we just need to fill values around bombs!

                for i in range(1, len(self.board)): # For every space in the board we need to find how many bombs are around it.
                        if (self.board[i].bomb):
                                continue # We don't need the value where bombs are so we skip.
                        space_val = 0
                        neighbors = self.board.getNeighbors(i) # We'll get the valid indices in separate function.
                        for index in neighbors: # Iterate through neighbor list
                                if (self.board[index].bomb): # If the board at that neighbor is a bomb...
                                        space_val += 1 # ...increment space value
                        self.board[i].adjMines = space_val # Set value at that board space.


        # Recursively uncovers neighbouring cells starting from a cell with 0 nearby mines.
        def propagate(self, space): 
                self.board[space].covered = False
                neighbors = self.board.getNeighbors(space)
                for neighbor in neighbors: # if neighbour has 0 adjacent mines and is not flagged, it will recusively uncover
                        if self.board[neighbor].adjMines == 0 and self.board[neighbor].flagged == False:
                                if self.board[neighbor].covered:
                                        self.propagate(neighbor)
                        elif self.board[neighbor].flagged: # Skip flagged cells
                                continue
                        else:
                                #print(f"Cell {neighbor}")
                                self.board[neighbor].covered = False


        # Display an error message and wait for the user to press "ENTER". Needed to preserve help messages before clearing terminal.
        def printErr(self, msg): 
                print(msg)
                input("Press [ENTER] to continue...\n")


        # Obtains an input from the user and parses it into a game command, broken into [action, row, column].
        def getInput(self):
                i = True
                while i:
                        try:
                                inp_string = input('Mine a cell with m[row][col].\nToggle a flag with f[row][col].\nPlease give command: ') # Ask for command.
                                com_type = inp_string[0].lower() # Parse first character for command type ("m" or "f")
                                if com_type != 'm' and com_type != 'f':
                                        raise
                                inp_string = inp_string[1:len(inp_string)] # Remove first character from input string.
                
                                col = inp_string[len(inp_string)-1] # Look at end of input string for column letter.
                                cols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'] # Bank of possible letters.
                                if col not in cols:
                                        raise
                                col = cols.index(col) + 1 # Translate that column into numerical column position.
                                inp_string = inp_string[:len(inp_string)-1] # Remove last character from input string.
                
                                row = int(inp_string) # What's remaining of input string should be row number.
                                if row not in range(1, 11):
                                        raise
                                i = False
                        except:
                                err_msg = '\nCommand is faulty please follow command, row, column format.\n(Hint 1: To mine at row 1, column a, type "m1a")\n(Hint 2: To flag at row 7, column g, type "f7g")'
                                self.printErr(err_msg)
                                continue
                
                command = [] # Create command value.
                command.append(com_type) # Add the "m" or "f"
                command.append(row) # Add row number.
                command.append(col) # Add column number.
                return command # Return parsed input.



        #Collects the bomb amount from the user and generates an initial list of bomb space indices.
        def configure(self):
                # COLLECT BOMB AMOUNT (DIFFICTULTY)
                i = 0
                while i == 0: # This while loop is purely for error handling. We don't stop asking until we get workable input!
                        try:
                                self.bomb_ct = int(input('How many bombs should there be?: '))
                                if self.bomb_ct < 10 or self.bomb_ct > 20: # Bomb count must be between 10 and 20 per the requirements.
                                        raise
                                i = 1
                        except:
                                print("Invalid bomb count. Please input again.")

                self.bomb_spaces = random.sample(range(1,101), self.bomb_ct) # Randomly select bomb locations on the board without duplicates



        '''
        Main game logic function. First, it obtains a valid command from the user and derives the space from the last two components. 
        Handles the operations necessary to flag a Cell(directly alters a Cell's flagged attribute) and handles all rule checks. 
        If the command is to mine, the Cell is uncovered. If the Cell has no adjacent mines, propagate() is called, which uncovers the Cell automatically. 
        If not, the Cell is uncovered directly in move(). Behavior is slightly different based on the prebomb attribute. 
        If it is set to True, the selected space is checked for presence in the randomly generated bomb_spaces list. 
        If it is present, then a new bomb_space is generated. 
        Once the bomb_spaces list is adjusted, placeBombs() is called, installing bombs in the board attribute. 
        Then, the Cell is uncovered as normal. If a bomb space is selected and prebomb is False, all bomb spaces are uncovered, and the game status is set to “Game Over: Loss”.
        '''
        def move(self, prebomb=False):
                self.total_moves += 1 # Increment total moves
                user_input = self.getInput() # Helper function gives us actionable command.
                space = ((user_input[1]-1)*10) + user_input[2] # Translate col and row from input into board space.
                
                if user_input[0] == 'f': # If we got a flag command, we place the flag on display.
                        if not self.board[space].flagged: # Empty space means flag is allowed.
                                        if self.flag_ct + 1 > self.bomb_ct: # Also got to check that we don't place too many flags.
                                                self.printErr("Cannot flag any more spaces. Please unflag with flag command.")
                                        elif not self.board[space].covered:
                                                self.printErr("Cannot flag an uncovered space.")
                                        else:
                                                self.board[space].flagged = True # Put a flag on the display!
                                                self.flag_ct += 1 # Increment the amount of flags on board.
                                                if not self.board[space].bomb:
                                                        self.wrong_flags += 1 # Increment wrong flags if flag is placed on non-bomb space
                        elif self.board[space].flagged: # Flag exists in current space, remove it.
                                self.board[space].flagged = False # Set flag to empty space.
                                self.flag_ct -= 1 # Decrement the amount of flags on board.
                
                elif user_input[0] == 'm': # We have a mine command!
                        if self.board[space].flagged: # Are we mining on a flag space?
                                self.printErr('Cannot mine a flag given space.') # We don't actually do anything. We just say a flag is in the way.
                        else:
                                if prebomb:
                                        # SPACE-BOMB COLLISION PROBLEM
                                        if space in self.bomb_spaces: # In the event the selected space is where a mine was planned to be...
                                                problem_index = self.bomb_spaces.index(space) # Isolate where in the list of bomb spaces the user space and bomb collide.
                                                while space == self.bomb_spaces[problem_index]: # While these two values are the same...
                                                        self.bomb_spaces[problem_index] = random.randint(1, 100) # ...we will reroll that bomb space.
                                                        i = 0 # Then we'll check how many times the new bomb space value appears.
                                                        for place in self.bomb_spaces: # Check every bomb space
                                                                if self.bomb_spaces[problem_index] == place: # If the new space appears in bomb spaces, increment.
                                                                        i += 1 # This should increment only once (when the new space compares itself).
                                                        if i > 1: # If the new bomb space increments multiple times, we still have a collision.
                                                                self.bomb_spaces[problem_index] = space # We can't let the while loop end so reset with space.
                                        
                                        # CALL BOARD GENERATION
                                        self.placeBombs()
                                        # UPDATE BOARD w/ FIRST SPACE
                                        if self.board[space].adjMines == 0:
                                                self.propagate(space) # Reveal spaces around the 0 space.
                                        else:
                                                self.board[space].covered = False
                                else:
                                        # There's a few things we check here:
                                                # Is the space a bomb?
                                                # Is the space a flag?
                                                # Is the space 0?
                                                # Is the space any other value?
                                        # We will check if the space is a bomb next.
                                        if self.board[space].bomb:
                                                for bomb in self.bomb_spaces: # Reveal all bombs on the board.
                                                        self.board[bomb].covered = False
                                                self.status = "Game Over: Loss" # Lose the game.
                                        # We will check if the space is the value 0.
                                        elif self.board[space].adjMines == 0: # 0 is a special value because we...
                                                self.propagate(space) # ...reveal the neighbor values.
                                        # The space must be empty and a regular number. Reveal it!
                                        else:
                                                self.board[space].covered = False


        #Checks if all non-bomb spaces are uncovered. Doesn't return anything, but sets status to Victory if necessary.
        def checkWin(self):
                # CHECK WIN CONDITION
                remaining_space_check = 0
                for index in range(1, len(self.board)): # Compare all board spaces
                        if self.board[index].covered:
                                remaining_space_check += 1 # Increment remaining empty or flagged spaces.
                if remaining_space_check == self.bomb_ct: # When there are the same amount of empty or flagged spaces as bombs on the field...
                        self.status = "Victory!" # The game has been won! End game loop.
                    

        # Check if all bombs have been correctly placed on the board. Needed to ensure first mined cell doesn't actually have a bomb in it.
        def checkBombPlacement(self): 
                bombed_spaces = 0
                for index in range(1, len(self.board)):
                        if self.board[index].bomb:
                                bombed_spaces += 1 # Count the number of bombs currently on the board
                return bombed_spaces == self.bomb_ct # Return true if bomb count matches the intended total


        '''
        Comprises the main game loop. Initially configures the game with configure(). 
        Then, runs a while loop, which prints the state of the game (printGame()) and requests a command (move()). 
        The optional parameter for move is set to True in this loop(see move() description). 
        This loop ends once the bombs have been placed (once the user uncovers their first cell). 
        After that, another loop begins, performing essentially the same function, with two differences. 
        The optional command in move() is no longer set, and the checkWin() function is called at the end of every iteration. 
        The loop breaks once the game status is no longer “Playing”.
        '''
        def play(self): # Configures the board, processes moves, and handle win/loss
                self.configure() # Ask user for bomb count and generate bomb locations
                while not self.checkBombPlacement(): # Makes sure bombs are properly placed before starting the game
                        self.printGame()
                        #print(f"Bomb Spaces: {self.bomb_spaces}")
                        self.move(True)
                        clear()
                while self.status == 'Playing':
                        self.printGame() # Display the current board
                        #print(f"Bomb Spaces: {self.bomb_spaces}")
                        self.move()
                        self.checkWin()
                        clear() # Clear screen for a fresh board display
                self.printGame()
                return



'''
Entity that coordinates initial contact with the user. It is responsible for printing an initial introductory message, as well as enabling multiple games per execution.
'''
class GameManager: # Handles showing instructions, new games, and replayability
        #GameManager doesn't need any attributes.
        def __init__(self):
                return
        
        # Creates a new game instance and start playing it
        def newGame(self): 
                newgame = Game()
                newgame.play()
        
        # Display the initial instruction to the player.
        def start_message(self): 
                print('Welcome to Minesweeper!')
                print('--------------------------------')
                print('HOW TO PLAY:')
                print('- Goal: uncover all safe spaces without hitting a mine.')
                print('- The numbers show how many mines are in the surrounding spaces.')
                print('- Commands (one command per turn):')
                print('    m[row][col] → Uncover a space.')
                print('        Example: m3b means uncover row 3, column b.')
                print('    f[row][col] → Flag or unflag a space.')
                print('        Example: f5h means place/remove a flag at row 5, column h.')
                print('- Win by uncovering every safe space. If you hit a mine, you lose!.')
                print('--------------------------------')
       
        # Start the game manager to show introduction instrution, run game and handle replays.
        def start(self):
                self.start_message() # Displays instruction to player
                while True:
                        self.newGame() # Start a new game
                        choice = input("Play again?(yes/no): ") # Ask if player want to reply
                        if choice.lower() == 'yes' or choice.lower() == 'y':
                                clear() # Clear screen for a fresh game
                                continue # Starts new game
                        else:
                                break # Exit loop and end the program

# Create a GameManager instance and start the minesweeper game
def main(): 
        manager = GameManager()
        manager.start()

main()
